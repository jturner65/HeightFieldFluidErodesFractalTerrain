package sqSqErosionSimPkg;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/**
 * class to hold all globally defined static consts (gui constants defined in myGui)
 * @author John
 *
 */

public class myConsts {
	//global variables
	public static final float globZPlane = 5f;	

	///
	//const indexes for flags array
	///	
	//////////
	//generation and terrain display
	//////////	
	// if making quad-based squaresquare subdivision
	public static final int sqSqSub 					= 0;
	//true if using loop subdivision, false otherwise
	public static final int loopSub 					= 1;
	//true if using catmull-clark subdivision, false otherwise
	public static final int catClkSub 					= 2;
	// if able to subdivide
	public static final int subEnabled 					= 3;
	//whether or not to multiple random value generated by terrain by normal of vert at that position - for terrain on a closed surface
	public static final int multByNormal 				= 4;	
	// if drawing from height map
	public static final int heightProc 					= 5;
	// randomly generate height modifications in sqsq subdivision?
	public static final int randomHeight 				= 6;       
	//if height map exists
	public static final int heightMapMade 				= 7;
	//whether or not we are in "erosion mode"
	public static final int erosionProc 				= 8;	
	//mesh has torroidal boundaries in at least one direction (wrap-around
	public static final int wrapAroundMesh 				= 9;
	//mesh is wrap around and needs to build initial water from "lake" source
	public static final int lakeSourceWrapMesh			= 10;
	//whether or not old loop subdivision mesh has been generated
	public static final int meshIsGenerated 			= 11;	
	//////////
	//simulation calculation related flags
	//////////	
	//execution of simulation cycles
	public static final int simulate					= 12;
	//calculate thermal weathering erosion in algorithm
	public static final int TWcalc 						= 13;
	//calculate hydraulic erosion in algorithm
	public static final int HEcalc 						= 14;
	//add rain step to erosion cycle
	public static final int Raincalc					= 15;
	//running a pipes-based 2nd order fluid transport simulation (ala obrien
	public static final int Pipes 						= 16;
	//whether or not to calculate lateral erosion on raised terrain being struck by leading edge of water
	public static final int calcLateralErosion 			= 17;
	//whether or not to use decreasing soil softness based on depth
	public static final int modSoilSoftness 			= 18;
	//rendering information in terrain (data visualising water levels, etc)
	public static final int dataVisualization 			= 19;		
	/////////
	//terrain mesh display flags
	/////////
	//display terrain mesh
	public static final int terrainMeshDisplay 			= 20;
	//whether or not to display terrain polygon edges (stroke)(useful to display terrain height changes and edges)
	public static final int strokeDisplayTerrain 		= 21;
	//whether or not we wish to see surface normals from terrain as lines
	public static final int showTerrainNormals 			= 22;
	// whether to draw using per-vertex normals or per-face normals for terrain
	public static final int vertTerrainNormals 			= 23;  	
	//////////
	//water display related flags
	//////////
	//display water mesh representation
	public static final int H2OMeshDisplay 				= 24;
	//whether or not we want to show velocity vectors for height nodes
	public static final int showH2OVelocity 			= 25;
	//whether or not to display water polygon edges (stroke)(useful to display water height changes)
	public static final int strokeDisplayH2O 			= 26;
	//whether or not we wish to see surface normals from water as lines
	public static final int showH2ONormals 				= 27;	
	//whether or not to use vertex normals for water shading		-	needs to be 1 more than show normals
	public static final int vertH2ONormals 				= 28;		
	//whether or not we wish to show boundary nodes as a different color - nodes that have at least 1 neighbor with no water
	public static final int showBoundaryNodes 			= 29;
	//display sed source vectors - lines from current node to source in mesh of sediment in node
	public static final int dispSedSrcVecs 				= 30;	
	//////////
	//sediment display related flags
	//////////
	//display sediment mesh
	public static final int sedMeshDisplay 				= 31;
	//whether or not to display sediment polygon edges (stroke)(useful to display terrain height changes and edges)
	public static final int strokeDisplaySED 			= 32;
	//whether or not we wish to see surface normals from sediment as lines
	public static final int showSEDNormals 				= 33;
	// whether to draw using per-vertex normals or per-face normals for sediment		-	needs to be 1 more than show normals
	public static final int vertSEDNormals 				= 34;	
	//////////
	//sediment capacity display related flags
	//////////
	//display sediment capacity mesh
	public static final int sedCapMeshDisplay 			= 35;
	//whether or not to display sediment capacity polygon edges (stroke)(useful to display terrain height changes and edges)
	public static final int strokeDisplaySedCap 		= 36;
	//whether or not we wish to see surface normals from sediment capacity as lines
	public static final int showSedCapNormals 			= 37;
	// whether to draw using per-vertex normals or per-face normals for sediment capacity		-	needs to be 1 more than show normals
	public static final int vertSedCapNormals 			= 38;  	
	//////////
	//sediment concentration display related flags
	//////////
	//display sediment concentration mesh
	public static final int sedConcMeshDisplay 			= 39;
	//whether or not to display sediment concentration polygon edges (stroke)(useful to display terrain height changes and edges)
	public static final int strokeDisplaySedConc 		= 40;
	//whether or not we wish to see surface normals from sediment concentration as lines
	public static final int showSedConcNormals 			= 41;
	// whether to draw using per-vertex normals or per-face normals for sediment concentration		-	needs to be 1 more than show normals
	public static final int vertSedConcNormals 			= 42;  	
	//////////
	//misc functionality constants
	//////////	
	//using the stam solver to model fluids in 3d
	public static final int useStamSolver 				= 43;
	//currently adding a velocity field programatically to a particular stam solver
	public static final int addVelStamSolver 			= 44;		
	//////////
	//misc gui constants
	//////////		
	// whether the gui is being displayed, or can be displayed - needs to be true to show gui in any condition
	public static final int renderGui 					= 45;    
	//whether or not the shift key is currently pressed
	public static final int shiftKeyPressed 			= 46;
	//whether we are allowing mouse-over gui display or not - gui is hidden and moving mouse to correct region will display a particular submenu of the gui
	public static final int guiMouseOverEnabled			= 47;
	//whether the button menu is currently being displayed
	public static final int guiDispButtonMenu			= 48;
	//whether the boolean flags menu is currently being dsiplayed
	public static final int guiDispBoolMenu				= 49;
	//whether the data-entry values at the bottom of the screen is currently being displayed
	public static final int guiDispBottomMenu			= 50;
	//whether the informational values at the top of the screen are currenlty being displayed
	public static final int guiDispTopDataVals			= 51;
	//whether the console is currently being displayed
	public static final int guiDispConsole				= 52;
	//whether the demo mode gui is enabled - must be false if using full gui
	public static final int renderDemoGui				= 53;
	//whether the demo mode gui is currently being displayed
	public static final int guiDispDemoMode				= 54;
	//whether we are in development or demo mode - true for demo, false for dev
	public static final int demoDevMode					= 55;
	//////////
	//debug related constants
	//////////
	//enable debugging functionality and display debug window
	public static final int debugMode 					= 56;
	//used to signal a single save of a screenshot
	public static final int savePic 					= 57;
	//whether or not we want to print out to console debug info about verts and faces
	public static final int debugModeCnsl 				= 58;
	//whether or not the debug output file is currently open
	public static final int debugOutputFileOpen 		= 59;
	//show a cutaway of terrain 1 node thick with constant x at specified location
	public static final int dispCutAwayX 				= 60;
	//show a cutaway of terrain 1 node thick with constant z at specified location
	public static final int dispCutAwayZ 				= 61;
	//display non-unity k values
	public static final int dispNon1KVals 				= 62;
	//display sed values at nodes remaining after sed transport step in pipes model
	public static final int dispSedTransLeftoverVals 	= 63;
	//display debug information related to subdivision processes
	public static final int debugSubdivision			= 64;
	//whether to scale sediment	w/greg's bandaid						
	public static final int scaleSedPipes				= 65;
	//limit the amount of water to be used to determine sediment capacity - any volume above a certain amount is ignored when calculating capacity
	public static final int limitWaterSedCap			= 66;
	//ignore y component of velocity in sediment caluclation
	public static final int ignoreYVelocity				= 67;
	//display tilt component of height nodes, sin of angle of tilt - using surface normal and velocity vector of water to get angle
	public static final int dispOriginalMesh			= 68;
	//display number of adj nodes at particular node as mesh height
	public static final int dispAdjNodes				= 69;
	//display vector to node that this node wraps to	
	public static final int dispWrapToNodes				= 70;
	//display pipe lengths values for each vertex	
	public static final int dispPipeLengths				= 71;
	//display outgoing flux values in debug mesh for each node
	public static final int dispFluxVals			 	= 72;
	//display height differences between each node and each of its adjacent nodes
	public static final int dispHeightDiffs				= 73;
	//apply lowest k value across mesh for all flux values
	public static final int useLowestKGlobally			= 74;		
	//subdivide river mesh, to smooth sides
	public static final int subdivRiverMesh				= 75;	
	//whether or not to rain on terrain next cycle
	public static final int rainOnTerrain1Cyc			= 76;
	//whether or not to use the flux mechanism to transport sediment
	public static final int useSedFlux					= 77;
	//whether or not to use sed concentration for sed transport mechanism
	public static final int useSedConc					= 78;	
	//whether or not to extrapolate sediment amt on dry nodes from nearest neighbors - only perform on nodes that are part of wrap around meshes
	public static final int pullSedFromDryNodes			= 79;	
	//whether or not to erode dry nodes when we pull from them during semi-lagrangian sed trans backstep
	public static final int erodeDryNodes				= 80;	
	//advect sediment deposition/erosion instead of pulling directly from node
	public static final int advectErosionDep			= 81;			
	//operate in batch mode, to attempt to determine optimal ks/kd values
	public static final int batchMode					= 82;	
	//display sailboat to help visualize velocity flow
	public static final int sailBoat					= 83;
	//display nodes that are "wrap around" - should be nodes along x edges in wrap around meshes				
	public static final int showWrapNodes				= 84;
	//display snapshot of actual values of old mesh (make a copy of the actual values of the heightMapAra) - snapshot taken via click of button in gui
	public static final int dispOldMeshVals				= 85;	
	//execute subdivision of loaded mesh in automated animation, for demo
	public static final int autoSubdivide				= 86;
	//stargger rain fall for demo
	public static final int staggerRainFall				= 87;	
	//turn on mouse active menus - uses bool ara in gui
	public static final int mseHotspotMenusActive		= 88;	
	
	//use stored values for mesh and erosion constants (always uses flags settings)
	public static final int useStoredErosionMeshVals	= 89;
	//record pics in sequence for a video
	public static final int recordVideo					= 90;
	
	//fluid transport methods - default is forward euler
	public static final int useMidpointMethod 			= 91;
	
	//use Matlab for finite element calc
	public static final int useMatlabFESolve			= 92;
	
	//display matlab fem calc results
	public static final int dispMatLabFEResults			= 93;
	
	//use shader to calculate pipes calculation
	public static final int useShdrForPipes				= 94;
	
	
	//number of boolean flags in flag array (consts above) - at least 5 higher than last value of consts above, to account for extra consts below used for sim lights flashing
	public static final int numFlags 					= 99;
	
	//consts below for lights showing execution of particular simulation steps
	//turn on and off when particular procedures execute during simulation - always last 3 constants
	public static final int rainFallExec 				= numFlags - 3;
	public static final int fluvialExec 				= numFlags - 2;
	public static final int aeolianExec	 				= numFlags - 1;
	//turn on and off the notification lights that show when erosion routines are executed - this is offset to first flag, we add to it to determine which of the 
	//3 executing flags we wish to access
	public static final int notifyLightFlagOffset 		= numFlags - 3;

	//idxes of mesh types used to initialize camera, based on what mesh subroutine calls the initcam routine
	public static final int noMesh						= -1;
	public static final int genMesh 					= 0;
	public static final int damMesh 					= 1;
	public static final int fileMesh 					= 2;
	public static final int stamMesh 					= 3;
	public static final int riverMesh 					= 4;	
	
	/////////////////
	//simulation related variables
	////////////////
	
	//river meshes - 2nd page of selections offset
	public static final int meshRiverOffset 		= 11;	
	
	//generated meshes stuff - id's of various types of csg-generated meshes
	public static final int mesh_ramp 				        = 0;
	public static final int mesh_coneUp 			        = 1;
	public static final int mesh_coneDown 			        = 2;
	public static final int mesh_2coneDown 			        = 3;
	public static final int mesh_volcano 			        = 4;
	public static final int mesh_2volcano 			        = 5;
	//generated water-based meshes                          
	public static final int mesh_dam 				        = 6;
	public static final int mesh_damWall 			        = 7;
	public static final int mesh_riverLedge 		        = 8;
	public static final int mesh_column 			        = 9;
	public static final int mesh_tiltColumn 		        = 10;
	public static final int mesh_tiltShelfColumn 	        = 11;
	
	public static final int mesh_riverPrimary 				= 12;			//1
	public static final int mesh_riverStraightPier 			= 13;
	public static final int mesh_riverStraightTributary 	= 14;
	public static final int mesh_riverStraight2Pier 		= 15;
	public static final int mesh_riverStraight2Tributary 	= 16;
	public static final int mesh_riverStraight2Trib2Pier 	= 17;			//6

	public static final int mesh_riverColumn 				= 18;			//7
	public static final int mesh_riverManyColumns 			= 19;	
	public static final int mesh_columnWall 				= 20;
	public static final int mesh_waterAroundColumnWall 		= 21;
	public static final int mesh_damBetweenWalls 			= 22;
	public static final int mesh_damBetweenLargeRiver 		= 23;			//12

	//more river meshes - these are generated without pre-made trough
	//- this is a mess, need to get rid of offset and just use idx to determine mesh type - currently val - meshRiverOffset2 should be sent to the buildTestMesh
	public static final int mesh_riverFlatTerrain 			= 24;				
	public static final int mesh_river1Boulder 				= 25;
	public static final int mesh_river2Boulder 				= 26;
	public static final int mesh_river3Boulder				= 27;
	public static final int mesh_riverGen4 					= 28;				//18	
	
	//file mesh consts - used to index into ara of initialisation flags
	public static final int mesh_fileSmall 					= 29;			//small mountain				
	public static final int mesh_fileLargeFlat 				= 30;			//large mountain
	public static final int mesh_fileLargeTilt 				= 31;			//large tilt mountain
	public static final int mesh_fileAutoSubSmall 			= 32;			//autosubdivide small 
	public static final int mesh_fileAutoSubLargeTilt 		= 33;			//autosubdivide large tilt
	//torus meshes
	public static final int mesh_torus1	                    = 34;		
	public static final int mesh_torus2	                    = 35;	
	public static final int mesh_torus3	                    = 36;
	public static final int mesh_torus4	                    = 37;		
	public static final int mesh_torus5	                    = 38;
	public static final int mesh_torus6	                    = 39;
	
	public static final int numTotMeshes 					= 40;
	
		
	//amt of time that passes between iterations
	public static final double globDeltaTMax = 5.0;        //modify for higher-than-1 values
	public static final double baseDeltaT = 1.0;

	//initial simCycles per TW execution - 0 for no TW execution
	public static final int initSimTWCycles = 0;
	//initial simCycles per HE execution - 0 for no HE execution
	public static final int initSimHECycles = 0;
	//initial simCycles per Rain execution - 0 for no Rain execution
	public static final int initSimRainCycles = 0;
	
	//fluid transport models to be used
	//position-based water movement
	public static final int firstOrder = 0;
	//velocity based water movement
	public static final int secondOrder = 1;

	//value for gray - used in all 3 positions
	public static final int globGrayVal = 200;
	//used for calculations to account for error in double/float calcs
	public static final double epsValCalc = .0000000001;
	//used for displaying quantities - below this is considered 0 for display purposes only
	public static final double epsValDisplay = .00001;
	//large eps val - test purposes only
	public static final double epsValLarge = .001;
	
	//max number of sailboats
	public static final int maxNumSailBoats = 30;	
	
	//pipes water transport constants - to be varied via gui during sim
	//gravitational constant
	public static final double grav = 9.8; 
	public static final myVector gravVec = new myVector(0,-1*grav, 0);
	//pressure constant
	public static final double rho = 1;	
	
	//ratio of water to no water - the bigger this number, the smaller the water amount needed to be considered "no water"
	public static final double NoWater = 1000;
	
	/////////////////////
	//global min/max arrays' idx's
	/////////////////////
	
 	//idx's of min and max ara
	public static final int numGlobValVars 	= 15;//number of glob value arrays used for value storage
	public static final int numGlobVisVars 	= 3;// 4;//number of glob value arrays used for visualisation use 4 to include elev and norms
	//used for visualisation too
	public static final int NO_VAL 			= -1;
	public static final int H2O 			= 0;
	public static final int SED 			= 1;
	public static final int SEDCAP 			= 2;	//sediment capacity of all h2o on mesh
	public static final int SEDCONC 		= 3;	//sediment concentration
	
	public static final int SED_R 			= 4;	//no visualisation, only an index to store the remaining sediment every turn
	
	public static final int COORD_X 		= 5;    //no visualisation, only used for data
	public static final int COORD_Y 		= 6;    //no visualisation, only used for data
	public static final int COORD_Z 		= 7;    //no visualisation, only used for data
	public static final int Vel_X 			= 8;
	public static final int Vel_Y 			= 9;
	public static final int Vel_Z 			= 10;
	public static final int Vel_Mag 		= 11;
	
	public static final int ERODED_SLOPE 	= 12; 	//node to node slope, used for determining efficacy of erosion constants - use abs val of node-node height diffs
	public static final int EXTREME_SLOPE 	= 13;	//counts # of node pairs within 90% of highest abs val eroded slope (max) or 110% of lowest slope val (min)
	public static final int FEMval 			= 14;
	
	
	//selection button values
    public static final int butMesh_riverPrimary 		        = 1;//     mesh_riverPrimary 		
    public static final int butMesh_riverStraightPier           = 2;//     mesh_riverStraightPier     
    public static final int butMesh_riverStraightTributary      = 3;//     mesh_riverStraightTributary  
    public static final int butMesh_riverStraight2Pier          = 4;//     mesh_riverStraight2Pier       
    public static final int butMesh_riverStraight2Tributary     = 5;//     mesh_riverStraight2Tributary 
    public static final int butMesh_riverStraight2Trib2Pier     = 6;//     mesh_riverStraight2Trib2Pier 
    public static final int butMesh_dam                         = 7;//     mesh_dam            
    public static final int butMesh_damWall                     = 8;//     mesh_damWall          
    public static final int butMesh_riverLedge                  = 9;//     mesh_riverLedge        
    public static final int butMesh_column                      = 10;//    mesh_column      
    public static final int butMesh_tiltColumn                  = 11;//    mesh_tiltColumn     
    public static final int butMesh_tiltShelfColumn             = 12;//    mesh_tiltShelfColumn 
    public static final int butMesh_riverFlatTerrain            = 13;//    mesh_riverFlatTerrain	 
    public static final int butMesh_riverGen1                   = 14;//    mesh_river1Boulder          
    public static final int butMesh_riverGen2                   = 15;//    mesh_river2Boulder            
    public static final int butMesh_riverGen3                   = 16;//    mesh_river3Boulder             
    public static final int butMesh_autoSubMacroSmall           = 17;//    load file mesh, execute subdivision macro, convert to height map small mesh
    public static final int butMesh_autoSubMacroBigTilt         = 18;//    load file mesh, execute subdivision macro, convert to height map large mesh
    public static final int butMesh_ramp                        = 19;//    mesh_ramp                
	public static final int butMesh_coneUp                      = 20;//    mesh_coneUp               
	public static final int butMesh_coneDown                    = 21;//    mesh_coneDown       
	public static final int butMesh_2coneDown                   = 22;//    mesh_2coneDown           
	public static final int butMesh_volcano                     = 23;//    mesh_volcano              
    public static final int butMesh_2volcano                    = 24;//    mesh_2volcano             
    public static final int butMesh_riverColumn		            = 25;//    mesh_riverColumn		   
    public static final int butMesh_riverManyColumns 	        = 26;//    mesh_riverManyColumns 	   
    public static final int butMesh_columnWall                  = 27;//    mesh_columnWall            
    public static final int butMesh_waterAroundColumnWall       = 28;//    mesh_waterAroundColumnWall   
	public static final int butMesh_damBetweenWalls             = 29;//    mesh_damBetweenWalls        
	public static final int butMesh_damBetweenLargeRiver        = 30;//    mesh_damBetweenLargeRiver   
    public static final int butMesh_fileGenSmall                = 31;//    mesh_fileGenSmall
    public static final int butMesh_fileGenBigFlat              = 32;//    mesh_fileGenBigFlat
    public static final int butMesh_fileGenBigTilt              = 33;//    mesh_fileGenBigTilt
    public static final int butMesh_torus1						= 34;//   
    public static final int butMesh_torus2						= 35;//   
    public static final int butMesh_torus3						= 36;//   
    public static final int butMesh_torus4						= 37;//   
    public static final int butMesh_torus5						= 38;//   
    public static final int butMesh_torus6	                    = 39;//   
    public static final int butMesh_recordHMData                = 40;//   
    public static final int butMesh_compareHMData               = 41;//   
	public static final int butMesh_displayCmpHMData            = 42;//   
    public static final int butMesh_sqSqSubdivide               = 43;//   
    public static final int butMesh_catSubdivide                = 44;//   
    public static final int butMesh_genHeightMap                = 45;//   
    public static final int butMesh_smoothMesh                  = 46;//   
    public static final int butMesh_DebugMode                   = 47;//   
    public static final int butMesh_SavePic                     = 48;//   
    public static final int butIDRain 	                        = 49;     
    public static final int butIDHydraulic   	                = 50;     
    public static final int butIDThermal     	                = 51;     
    public static final int butAddSailBoat 		                = 52;     
    public static final int butRemoveSailBoat	                = 53;     
    public static final int butReset       		                = 54;     
    public static final int butRewindMeshSim     			    = 55;     
    public static final int butStopMeshSim     				    = 56;     
    public static final int butPlayPauseMeshSim     		    = 57;     
    public static final int butPlayplaylist     			    = 58;     
    public static final int butDispMatLabResults		        = 59;     
    public static final int butCallMatLab     				 	= 60;    
    public static final int butMesh_riverGen4					= 61;		//place holder temporarily - correspond to mesh idx for mesh_riverGen4
    //below used for demo screen, to trigger booleans
    public static final int butMesh_showVelocity 				= 155;
    public static final int butMesh_showOldMesh					= 156;
    public static final int butMesh_randomHeight 				= 157;
    public static final int butMesh_erosionProc					= 158;
    public static final int butMesh_DemoGenHeightMap			= 159;		//build heightmap completely

	public static final int[] butIDerode = {butIDRain,butIDHydraulic,butIDThermal};
	
	//array of buttons for selection from UI selection block
	public static final int[][][] butDevUIMeshAra = {
		{//page 1
			{ butMesh_riverPrimary, butMesh_riverStraightPier, butMesh_riverStraightTributary, butMesh_riverStraight2Pier, butMesh_riverStraight2Tributary, butMesh_riverStraight2Trib2Pier  },
			{ butMesh_dam, butMesh_damWall, butMesh_riverLedge, butMesh_column, butMesh_tiltColumn, butMesh_tiltShelfColumn },  	    
		    { butMesh_riverFlatTerrain, butMesh_riverGen1, butMesh_riverGen2, butMesh_riverGen3, butMesh_autoSubMacroSmall, butMesh_autoSubMacroBigTilt },       
		    { butMesh_ramp, butMesh_coneUp, butMesh_coneDown, butMesh_2coneDown, butMesh_volcano, butMesh_2volcano },     
		    { butMesh_riverColumn, butMesh_riverManyColumns, butMesh_columnWall, butMesh_waterAroundColumnWall, butMesh_damBetweenWalls, butMesh_damBetweenLargeRiver },     
		    { butMesh_fileGenSmall, butMesh_fileGenBigFlat, butMesh_fileGenBigTilt, butMesh_recordHMData, butMesh_compareHMData, butMesh_displayCmpHMData },     
		    { butMesh_sqSqSubdivide, butMesh_catSubdivide, butMesh_genHeightMap, butMesh_smoothMesh, butMesh_DebugMode, butMesh_SavePic },	     
		    { butIDRain, butIDHydraulic, butIDThermal, butAddSailBoat, butRemoveSailBoat, butReset },	     
		    { butRewindMeshSim, butStopMeshSim, butPlayPauseMeshSim, butPlayplaylist, butDispMatLabResults, butCallMatLab }	
		},
		{//page 2 - from shift	
		    { butMesh_torus1, butMesh_torus2, butMesh_torus3, butMesh_torus4, butMesh_torus5, butMesh_torus6 },  
			{ butMesh_dam, butMesh_damWall, butMesh_riverLedge, butMesh_column, butMesh_tiltColumn, butMesh_tiltShelfColumn },  	    
		    { butMesh_riverFlatTerrain, butMesh_riverGen1, butMesh_riverGen2, butMesh_riverGen3, butMesh_autoSubMacroSmall, butMesh_autoSubMacroBigTilt },       
		    { butMesh_ramp, butMesh_coneUp, butMesh_coneDown, butMesh_2coneDown, butMesh_volcano, butMesh_2volcano },     
		    { butMesh_riverColumn, butMesh_riverManyColumns, butMesh_columnWall, butMesh_waterAroundColumnWall, butMesh_damBetweenWalls, butMesh_damBetweenLargeRiver },     
		    { butMesh_fileGenSmall, butMesh_fileGenBigFlat, butMesh_fileGenBigTilt, butMesh_recordHMData, butMesh_compareHMData, butMesh_displayCmpHMData },     
		    { butMesh_sqSqSubdivide, butMesh_catSubdivide, butMesh_genHeightMap, butMesh_smoothMesh, butMesh_DebugMode, butMesh_SavePic },	     
		    { butIDRain, butIDHydraulic, butIDThermal, butAddSailBoat, butRemoveSailBoat, butReset },	     
		    { butRewindMeshSim, butStopMeshSim, butPlayPauseMeshSim, butPlayplaylist, butDispMatLabResults, butCallMatLab }
		}
	};
		    
	//array of buttons for selection from UI selection block
	public static final int[][][] butDemoUIMeshAra = {
		{//page 1
		    {//demo mode row 1 
		    butMesh_riverPrimary, butMesh_riverStraightPier, butMesh_riverStraightTributary, butMesh_riverStraight2Pier, butMesh_riverStraight2Tributary, butMesh_riverStraight2Trib2Pier , 
		    butMesh_dam, butMesh_damWall, butMesh_riverLedge, butMesh_column, butMesh_tiltColumn, butMesh_tiltShelfColumn,butMesh_riverFlatTerrain, butMesh_riverGen1, butMesh_riverGen2, butMesh_riverGen3, butMesh_autoSubMacroSmall, butMesh_autoSubMacroBigTilt},	
		    {//demo mode row 2  
		    butMesh_ramp, butMesh_coneUp, butMesh_coneDown, butMesh_2coneDown, butMesh_volcano, butMesh_2volcano, butMesh_riverColumn, butMesh_riverManyColumns, butMesh_columnWall, butMesh_waterAroundColumnWall, butMesh_damBetweenWalls, butMesh_damBetweenLargeRiver,
		    butRewindMeshSim, butStopMeshSim, butPlayPauseMeshSim,butAddSailBoat, butRemoveSailBoat, butReset }		},
		{//page 2 - from shift	
		    {//demo mode row 1
		    butMesh_torus1, butMesh_torus2, butMesh_torus3, butMesh_torus4, butMesh_torus5, butMesh_torus6, 
		    butMesh_dam, butMesh_damWall, butMesh_riverLedge, butMesh_column, butMesh_tiltColumn, butMesh_tiltShelfColumn,butMesh_riverFlatTerrain, butMesh_riverGen1, butMesh_riverGen2, butMesh_riverGen3, butMesh_autoSubMacroSmall, butMesh_autoSubMacroBigTilt},	
		    {//demo mode row 2  
		    butMesh_ramp, butMesh_coneUp, butMesh_coneDown, butMesh_2coneDown, butMesh_volcano, butMesh_2volcano, butMesh_riverColumn, butMesh_riverManyColumns, butMesh_columnWall, butMesh_waterAroundColumnWall, butMesh_damBetweenWalls, butMesh_damBetweenLargeRiver,
		    butRewindMeshSim, butStopMeshSim, butPlayPauseMeshSim,butAddSailBoat, butRemoveSailBoat, butReset }		}
	};		
	
	//////////////////
	//gui display related constants
	//////////////////

	/*
	 * map holding mappings from button id's to mesh idx's - NOTE:entries can be changed (map var cannot be reassigned but individual entries can be over-written)
	 */
	public static final HashMap<Integer, Integer> butToMeshIDX;
	static{
		butToMeshIDX = new HashMap<Integer, Integer>();
		butToMeshIDX.put(butMesh_riverPrimary 		    , mesh_riverPrimary 		    );
		butToMeshIDX.put(butMesh_riverStraightPier      , mesh_riverStraightPier       	);
		butToMeshIDX.put(butMesh_riverStraightTributary , mesh_riverStraightTributary  	);
		butToMeshIDX.put(butMesh_riverStraight2Pier     , mesh_riverStraight2Pier      	);
		butToMeshIDX.put(butMesh_riverStraight2Tributary, mesh_riverStraight2Tributary 	);
		butToMeshIDX.put(butMesh_riverStraight2Trib2Pier, mesh_riverStraight2Trib2Pier 	);
		butToMeshIDX.put(butMesh_dam                    , mesh_dam                     	);
		butToMeshIDX.put(butMesh_damWall                , mesh_damWall                 	);
		butToMeshIDX.put(butMesh_riverLedge             , mesh_riverLedge              	);
		butToMeshIDX.put(butMesh_column                 , mesh_column                  	);
		butToMeshIDX.put(butMesh_tiltColumn             , mesh_tiltColumn              	);
		butToMeshIDX.put(butMesh_tiltShelfColumn        , mesh_tiltShelfColumn         	);
		butToMeshIDX.put(butMesh_riverFlatTerrain       , mesh_riverFlatTerrain	    	);
		butToMeshIDX.put(butMesh_riverGen1              , mesh_river1Boulder           	);
		butToMeshIDX.put(butMesh_riverGen2              , mesh_river2Boulder           	);
		butToMeshIDX.put(butMesh_riverGen3              , mesh_river3Boulder           	);
		butToMeshIDX.put(butMesh_riverGen4              , mesh_riverGen4				);		
		butToMeshIDX.put(butMesh_ramp                   , mesh_ramp                    	);
		butToMeshIDX.put(butMesh_coneUp                 , mesh_coneUp                  	);
		butToMeshIDX.put(butMesh_coneDown               , mesh_coneDown                	);
		butToMeshIDX.put(butMesh_2coneDown              , mesh_2coneDown               	);
		butToMeshIDX.put(butMesh_volcano                , mesh_volcano                 	);
		butToMeshIDX.put(butMesh_2volcano               , mesh_2volcano                	);
		butToMeshIDX.put(butMesh_riverColumn		    , mesh_riverColumn		        );
		butToMeshIDX.put(butMesh_riverManyColumns 	    , mesh_riverManyColumns 	    );
		butToMeshIDX.put(butMesh_columnWall             , mesh_columnWall              	);
		butToMeshIDX.put(butMesh_waterAroundColumnWall  , mesh_waterAroundColumnWall   	);
		butToMeshIDX.put(butMesh_damBetweenWalls        , mesh_damBetweenWalls         	);
		butToMeshIDX.put(butMesh_damBetweenLargeRiver   , mesh_damBetweenLargeRiver    	);
		butToMeshIDX.put(butMesh_fileGenSmall           , mesh_fileSmall 				);
		butToMeshIDX.put(butMesh_fileGenBigFlat         , mesh_fileLargeFlat 			);
		butToMeshIDX.put(butMesh_fileGenBigTilt         , mesh_fileLargeTilt 			);
		butToMeshIDX.put(butMesh_autoSubMacroSmall      , mesh_fileAutoSubSmall 		);
		butToMeshIDX.put(butMesh_autoSubMacroBigTilt    , mesh_fileAutoSubLargeTilt    	);		
		butToMeshIDX.put(butMesh_torus1					, mesh_torus1                   );
		butToMeshIDX.put(butMesh_torus2					, mesh_torus2                   );
		butToMeshIDX.put(butMesh_torus3					, mesh_torus3                   );
		butToMeshIDX.put(butMesh_torus4					, mesh_torus4                   );
		butToMeshIDX.put(butMesh_torus5					, mesh_torus5                   );
		butToMeshIDX.put(butMesh_torus6	                , mesh_torus6                   );
		butToMeshIDX.put(-1, -1);				
	}
	
	/*
	 * map holding mappings from button idx to icon idx (to correspond to layouts) - TODO : this is crap, finish gui object class
	 */
	public static final HashMap<Integer, Integer> butToIconIDX;
	static{
		butToIconIDX = new HashMap<Integer, Integer>();  
		butToIconIDX.put(butMesh_riverPrimary 		     ,1);
		butToIconIDX.put(butMesh_riverStraightPier       ,2);
		butToIconIDX.put(butMesh_riverStraightTributary  ,3);
		butToIconIDX.put(butMesh_riverStraight2Pier      ,4);
		butToIconIDX.put(butMesh_riverStraight2Tributary ,5);
		butToIconIDX.put(butMesh_riverStraight2Trib2Pier ,6);
		butToIconIDX.put(butMesh_dam                     ,7);
		butToIconIDX.put(butMesh_damWall                 ,8);
		butToIconIDX.put(butMesh_riverLedge              ,9);
		butToIconIDX.put(butMesh_column                  ,10);
		butToIconIDX.put(butMesh_tiltColumn              ,11);
		butToIconIDX.put(butMesh_tiltShelfColumn         ,12);
		butToIconIDX.put(butMesh_riverFlatTerrain        ,13);
		butToIconIDX.put(butMesh_riverGen1               ,14);
		butToIconIDX.put(butMesh_riverGen2               ,15);
		butToIconIDX.put(butMesh_riverGen3               ,16);
		butToIconIDX.put(butMesh_autoSubMacroSmall       ,17);
		butToIconIDX.put(butMesh_autoSubMacroBigTilt     ,18);
		butToIconIDX.put(butMesh_ramp                    ,19);
		butToIconIDX.put(butMesh_coneUp                  ,20);
		butToIconIDX.put(butMesh_coneDown                ,21);
		butToIconIDX.put(butMesh_2coneDown               ,22);
		butToIconIDX.put(butMesh_volcano                 ,23);
		butToIconIDX.put(butMesh_2volcano                ,24);
		butToIconIDX.put(butMesh_riverColumn		     ,25);
		butToIconIDX.put(butMesh_riverManyColumns 	     ,26);
		butToIconIDX.put(butMesh_columnWall              ,27);
		butToIconIDX.put(butMesh_waterAroundColumnWall   ,28);
		butToIconIDX.put(butMesh_damBetweenWalls         ,29);
		butToIconIDX.put(butMesh_damBetweenLargeRiver    ,30);
		butToIconIDX.put(butMesh_fileGenSmall            ,31);
		butToIconIDX.put(butMesh_fileGenBigFlat          ,32);
		butToIconIDX.put(butMesh_fileGenBigTilt          ,33);
		butToIconIDX.put(butMesh_recordHMData            ,34);
		butToIconIDX.put(butMesh_compareHMData           ,35);
		butToIconIDX.put(butMesh_displayCmpHMData        ,36);
		butToIconIDX.put(butMesh_sqSqSubdivide           ,37);
		butToIconIDX.put(butMesh_catSubdivide            ,38);
		butToIconIDX.put(butMesh_genHeightMap            ,39);
		butToIconIDX.put(butMesh_smoothMesh              ,40);
		butToIconIDX.put(butMesh_DebugMode               ,41);
		butToIconIDX.put(butMesh_SavePic                 ,42);
		butToIconIDX.put(butIDRain 	                     ,43);
		butToIconIDX.put(butIDHydraulic   	             ,44);
		butToIconIDX.put(butIDThermal     	             ,45);
		butToIconIDX.put(butAddSailBoat 		         ,46);   
		butToIconIDX.put(butRemoveSailBoat	             ,47);
		butToIconIDX.put(butReset       		         ,48);   
		butToIconIDX.put(butRewindMeshSim     			 ,49);
		butToIconIDX.put(butStopMeshSim     			 ,50);
		butToIconIDX.put(butPlayPauseMeshSim     		 ,51);
		butToIconIDX.put(butPlayplaylist     			 ,52);
		butToIconIDX.put(butDispMatLabResults		     ,53);
		butToIconIDX.put(butCallMatLab     				 ,54);
		butToIconIDX.put(butMesh_riverGen4				 ,55);                                                          
		butToIconIDX.put(butMesh_torus1					 ,56);
		butToIconIDX.put(butMesh_torus2					 ,57);
		butToIconIDX.put(butMesh_torus3				 	 ,58);
		butToIconIDX.put(butMesh_torus4					 ,59);
		butToIconIDX.put(butMesh_torus5					 ,60);
		butToIconIDX.put(butMesh_torus6	                 ,61);				

		butToIconIDX.put(butMesh_showVelocity 			 ,155);
		butToIconIDX.put(butMesh_showOldMesh			 ,156);
		butToIconIDX.put(butMesh_randomHeight 			 ,157);
		butToIconIDX.put(butMesh_erosionProc			 ,158);
		butToIconIDX.put(butMesh_DemoGenHeightMap		 ,159);
		
		butToMeshIDX.put(-1, -1);				         
	}
	
	/*
	 * 2d array holding flag idx's of demo page display buttons
	 */
	
	public static final int[][] dmoSmMeshBoolValsByLoc = {
		{terrainMeshDisplay,  H2OMeshDisplay, sedMeshDisplay, sedCapMeshDisplay, sedConcMeshDisplay },								//mesh
		{strokeDisplayTerrain, strokeDisplayH2O, strokeDisplaySED, strokeDisplaySedCap, strokeDisplaySedConc },							//edges
		{vertTerrainNormals, vertH2ONormals, vertSEDNormals, vertSedCapNormals, vertSedConcNormals },				//shade by norms
	};

	//bool vals in demo sim menu - need to be same order as 1st row below
	public static final int[] dmoSmSimBoolVals = {showH2OVelocity, dispOriginalMesh, randomHeight, erosionProc};
	public static final int[][] dmoSmSimMenuValsByLoc = {
		{butMesh_showVelocity, butMesh_showOldMesh, butMesh_randomHeight, butMesh_erosionProc, butMesh_sqSqSubdivide, butMesh_DemoGenHeightMap},								//top row
		{butIDRain, butIDHydraulic, butIDThermal, butMesh_recordHMData, butMesh_compareHMData, butMesh_displayCmpHMData },						//bottom row
	};
	
	
	//array of idxes of boolean values that are not modifiable
	public static final int[] nonModBools = {heightMapMade, useStamSolver, wrapAroundMesh}; 
	
	//array of idxes of boolean values that are user modifiable related to subdivision, sim execution, terrain display, water/sediment display, misc components
	public static final int[][] modBoolsAra = {
		{subEnabled, randomHeight, heightProc, erosionProc, useMidpointMethod ,subdivRiverMesh},											//0 sub
		{simulate, TWcalc, HEcalc, Raincalc, Pipes, calcLateralErosion/*, modSoilSoftness*/},							//1 sim
		{terrainMeshDisplay, strokeDisplayTerrain, showTerrainNormals},													//2 ter
		{H2OMeshDisplay, strokeDisplayH2O, showH2ONormals, showBoundaryNodes, showH2OVelocity, dispSedSrcVecs},			//3 h2o
		{sedMeshDisplay, strokeDisplaySED, showSEDNormals},																//4 sed
		{sedCapMeshDisplay, strokeDisplaySedCap, showSedCapNormals},													//5 sedcap
		{sedConcMeshDisplay, strokeDisplaySedConc, showSedConcNormals},													//6 sedConc
		{batchMode, debugMode/*, renderGui*/},																			//7 misc
		{vertTerrainNormals, vertH2ONormals, vertSEDNormals, vertSedCapNormals, vertSedConcNormals 	},					//8 display-related
		{/*debugModeCnsl*/staggerRainFall, dispCutAwayX, dispCutAwayZ, showWrapNodes/*debugSubdivision*/,  dispNon1KVals, dispSedTransLeftoverVals, 
			scaleSedPipes, limitWaterSedCap, dispOriginalMesh, ignoreYVelocity,  dispAdjNodes, dispWrapToNodes,
			dispFluxVals, dispHeightDiffs, dispPipeLengths, useLowestKGlobally, useSedFlux, useSedConc, pullSedFromDryNodes, erodeDryNodes /*, advectErosionDep*/}}; 	//9 debug														//8 debug	

	//array of subdivision flags
	public static final int[] subDivFlags = {sqSqSub, catClkSub, loopSub};	
	
	//////////////
	//structures holding objects used in simulation
	/////////////
	//holds potential numeric values
	//public static final Set<Character> numKeys = new HashSet<Character>(Arrays.asList( new Character[] {'1','2','3','4','5','6','7','8','9','0'} ));

	public static final ArrayList<String> erosionProcStrAra = new ArrayList<String>(Arrays.asList (new String[] 
	  {"","ThermalWeathering", "HydraulicErosion", "Rain", "COMBOFirstOrder" } ));	
	
	//initial camera positions, idx'ed by mesh ID
	public static final ArrayList<Double[]> initCamPositions = new ArrayList<Double[]>(Arrays.asList (new Double[][] { 			
		{6.7, -0.88,  38.0},	 //mesh_ramp 				        = 0;   
		{6.7,  -.62,  30.0},	 //mesh_coneUp 			            = 1;   
		{6.82, -.32,  35.0},	 //mesh_coneDown 			        = 2;   
		{6.82, -.32,  35.0},	 //mesh_2coneDown 			        = 3;   
		{6.82, -.32,  30.0},	 //mesh_volcano 			        = 4;   
		{6.82, -.32,  30.0},	 //mesh_2volcano 			        = 5;   
		{6.7,  -0.64, 33.6},	 //mesh_dam 				        = 6;   
		{6.7,  -.62,  28.8},	 //mesh_damWall 			        = 7;   
		{6.7,  -.78,  28.8},	 //mesh_riverLedge 		            = 8;   
		{6.7,  -.7,   28.0},	 //mesh_column 			            = 9;   
		{6.02, -.66,  30.0},	 //mesh_tiltColumn 		            = 10;  
		{6.02, -.66,  30.0},	 //mesh_tiltShelfColumn 	        = 11;  			                                            
		{6.7, -0.25, 35.6}, 	 //mesh_riverPrimary 				= 12;	
		{6.7, -0.26, 35.6}, 	 //mesh_riverStraightPier 		    = 13;  
		{6.7, -0.27, 35.6},		 //mesh_riverStraightTributary 	    = 14;  
		{6.7, -0.28, 35.6}, 	 //mesh_riverStraight2Pier 		    = 15;  
		{6.7, -0.29, 35.6}, 	 //mesh_riverStraight2Tributary 	= 16;  
		{6.7, -0.30, 35.6}, 	 //mesh_riverStraight2Trib2Pier 	= 17;			                                            
		{6.66, -0.45, 35.6},	 //mesh_riverColumn 				= 18;	
		{6.66, -0.46, 35.6},	 //mesh_riverManyColumns 			= 19;	
		{6.76, -0.47, 35.6},	 //mesh_columnWall 				    = 20;  
		{6.76, -0.48, 35.6},	 //mesh_waterAroundColumnWall 	   	= 21;  
		{6.70, -0.49, 35.6},	 //mesh_damBetweenWalls 			= 22;  
		{6.70, -0.50, 35.6},	 //mesh_damBetweenLargeRiver 		= 23;				                                            
		{6.70, -0.10, 35.6},	 //mesh_riverFlatTerrain 			= 24;	
		{6.70, -0.11, 35.6},	 //mesh_river1Boulder 			    = 25;  
		{6.70, -0.12, 35.6},	 //mesh_river2Boulder 			  	= 26;  
		{6.70, -0.13, 35.6},	 //mesh_river3Boulder				= 27;  
		{6.70, -0.14, 35.6}, 	 //mesh_riverGen4 				   	= 28;	
		{6.76, 	-.76, 4.3},  	 //mesh_fileSmall 				    = 29;	
		{17.0, 	-.47, 12.4}, 	 //mesh_fileLargeFlat 			    = 30;	
		{-3.0, 	-.48, 13.5}, 	 //mesh_fileLargeTilt 			    = 31;	
		{9.7, 	-.49, 11.0}, 	 //mesh_fileAutoSubSmall 			= 32;	
		{-11.8, -.15, 20.20},	 //mesh_fileAutoSubLargeTilt 		= 33;		                                        
		{6.75, -0.13, 35.6},	//mesh_torus1	                    = 34;	
		{6.75, -0.14, 35.6},	//mesh_torus2	                    = 35;	
		{6.75, -0.15, 35.6},	//mesh_torus3	                    = 36;  
		{6.75, -0.16, 35.6},	//mesh_torus4	                    = 37;	
		{6.75, -0.17, 35.6},	//mesh_torus5	                    = 38;  
		{6.75, -0.18, 35.6},	//mesh_torus6	                    = 39;  	
		{-11.8, -.10, 20.20},	//empty entry	
		{-11.8, -.11, 20.20},	//empty entry	
		{-11.8, -.12, 20.20},	//empty entry	
		{-11.8, -.13, 20.20},	//empty entry	
		{-11.8, -.14, 20.20},	//empty entry	
		{-11.8, -.15, 20.20},	//empty entry	
		{-11.8, -.16, 20.20},	//empty entry	
		{-11.8, -.17, 20.20},	//empty entry	
		{-11.8, -.18, 20.20},	//empty entry	
		{-11.8, -.19, 20.20},	//empty entry	
		{-11.8, -.20, 20.20},	//empty entry	
		{-11.8, -.21, 20.20}	//empty entry	
	} ));
	
	//start coords of camera for various generated and dam meshes
	public static final ArrayList<Double[]> initGenDamCamPositions = new ArrayList<Double[]>(Arrays.asList (new Double[][] { 
			{6.8,  -0.78, 25.0}, 
			{6.7, -0.88,  38.0},			//double ramp
			{6.7,  -.62,  30.0},			//inverted cone mountain
			{6.82, -.32,  35.0},			//icecream cone	
			{6.82, -.32,  35.0},			//dual cone 
			{6.82, -.32,  30.0},			//volcano
			{6.82, -.32,  30.0},			//double volcano
			{6.7,  -0.64, 33.6},			//dam
			{6.7,  -.62,  28.8},			//dam w/break
			{6.7,  -.78,  28.8},			//dam into riverbank
			{6.7,  -.7,   28.0},			//column of water
			{6.02, -.66,  30.0},			//tilted shelf
			{6.02, -.66,  30.0},			//tilted shelf w/wall
			{6.75, -0.13, 35.6}, 		    //torus
			{6.75, -0.14, 35.6}, 		    //torus
			{6.75, -0.15, 35.6}, 		    //torus
			{6.75, -0.16, 35.6}, 		    //torus
			{6.75, -0.17, 35.6}, 		    //torus
			{6.75, -0.18, 35.6}, 		    //torus
			{6.75, -0.19, 35.6}, 		    //torus		
			} ));
	//start coords of camera for various river meshes
	public static final ArrayList<Double[]> initRiverCamPositions = new ArrayList<Double[]>(Arrays.asList (new Double[][] { 
			{6.7, -0.24, 35.6}, 
			{6.7, -0.25, 35.6}, 		//main river mesh
			{6.7, -0.26, 35.6}, 		//single pier river mesh
			{6.7, -0.27, 35.6},			//single tributary river mesh
			{6.7, -0.28, 35.6}, 		//2-pier river mesh
			{6.7, -0.29, 35.6}, 		//2-trib river mesh
			{6.7, -0.30, 35.6}, 		//2pier/2trib river mesh
			{6.66, -0.45, 35.6}, 		//water surrounding single spike of terrain
			{6.66, -0.46, 35.6}, 		//water surrounding multiple spikes of terrain
			{6.76, -0.47, 35.6}, 		//single column of water in the middle of a raised circle of terrain
			{6.76, -0.48, 35.6}, 		//ring of terrain with column of water in middle and surrounded by water
			{6.70, -0.49, 35.6}, 		//wall of water with wall breaks on either side
			{6.70, -0.50, 35.6}, 		//2 walls of water in river
			{6.70, -0.10, 35.6}, 		//river flat
			{6.70, -0.11, 35.6}, 		//river 1 boulder
			{6.70, -0.12, 35.6}, 		//river 2 boulder
			{6.70, -0.13, 35.6}, 		//river 3 boulder
			{6.70, -0.14, 35.6}, 		//
			{6.70, -0.15, 35.6}, 		//
			} ));
	//start coords for various file-based meshes
	public static final ArrayList<Double[]> initFileCamPositions = new ArrayList<Double[]>(Arrays.asList (new Double[][] { 
			{6.7, -0.25, 35.6}, 
			{6.76, 	-.76, 4.3},
			{17.0, 	-.47, 12.4},
			{-3.0, 	-.48, 13.5},
			{9.7, 	-.49, 11.0},
			{-11.8, -.15, 20.20},
			{-11.8, -.16, 20.20},
			{-11.8, -.17, 20.20},
			{-11.8, -.18, 20.20},
			{-11.8, -.19, 20.20},
			{-11.8, -.20, 20.20},
			{-11.8, -.21, 20.20},
			{-11.8, -.22, 20.20},
			{-11.8, -.23, 22.20},
			} ));
	
	public static final ArrayList<Double[]> initStamCamPositions = new ArrayList<Double[]>(Arrays.asList (new Double[][] { 
			{26.8, -0.78, 200.0}, 
			{26.8, -0.78, 200.0}
			} ));

	//what boolean flags are set for each mesh, as consts - idxed by mesh ID
	public static final ArrayList<int[]> initMeshBoolFlagNames = new ArrayList<int[]>(Arrays.asList(new int[][] {
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, ignoreYVelocity, dispOriginalMesh, useLowestKGlobally, useSedFlux},//		mesh_ramp : idx : 0
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_coneUp : idx : 1
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_coneDown : idx : 2
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_2coneDown : idx : 3
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_volcano : idx : 4
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_2volcano : idx : 5
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, renderGui,  renderDemoGui, debugMode, scaleSedPipes, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_dam : idx : 6
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, renderGui,  renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_damWall : idx : 7
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, renderGui,  renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_riverLedge : idx : 8
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Pipes, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, vertH2ONormals, renderGui,  renderDemoGui, debugMode, scaleSedPipes, ignoreYVelocity, useLowestKGlobally},//		mesh_column : idx : 9
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, vertTerrainNormals, H2OMeshDisplay, vertH2ONormals, renderGui,  renderDemoGui, debugMode, scaleSedPipes, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_tiltColumn : idx : 10
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, vertH2ONormals, renderGui,  renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_tiltShelfColumn : idx : 11
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, renderGui,  renderDemoGui, debugMode, scaleSedPipes, useLowestKGlobally, useSedConc, pullSedFromDryNodes},//		mesh_riverPrimary : idx : 12
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, renderGui,  renderDemoGui, debugMode, scaleSedPipes, useLowestKGlobally, useSedConc, pullSedFromDryNodes},//		mesh_riverStraightPier : idx : 13
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, renderGui,  renderDemoGui, debugMode, dispNon1KVals, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_riverStraightTributary : idx : 14
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, renderGui,  renderDemoGui, debugMode, scaleSedPipes, useLowestKGlobally, useSedConc, pullSedFromDryNodes},//		mesh_riverStraight2Pier : idx : 15
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, renderGui,  renderDemoGui, debugMode, dispNon1KVals, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_riverStraight2Tributary : idx : 16
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, renderGui,  renderDemoGui, debugMode, dispNon1KVals, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_riverStraight2Trib2Pier : idx : 17
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, H2OMeshDisplay, useMidpointMethod, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_riverColumn : idx : 18
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, H2OMeshDisplay, useMidpointMethod, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_riverManyColumns : idx : 19
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, H2OMeshDisplay, useMidpointMethod, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_columnWall : idx : 20
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, H2OMeshDisplay, useMidpointMethod, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_waterAroundColumnWall : idx : 21
			{sqSqSub, heightMapMade, erosionProc, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, H2OMeshDisplay, useMidpointMethod, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_damBetweenWalls : idx : 22
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, renderGui, renderDemoGui, debugMode, scaleSedPipes, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_damBetweenLargeRiver : idx : 23
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, useMidpointMethod, H2OMeshDisplay, renderGui,  renderDemoGui, debugMode, scaleSedPipes, useLowestKGlobally, useSedConc, pullSedFromDryNodes},//		mesh_riverFlatTerrain : idx : 24
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, useMidpointMethod, terrainMeshDisplay, H2OMeshDisplay, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		mesh_river1Boulder : idx : 25
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, useMidpointMethod, terrainMeshDisplay, H2OMeshDisplay, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, useLowestKGlobally, staggerRainFall, useSedFlux},//		mesh_river2Boulder : idx : 26
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, useMidpointMethod, terrainMeshDisplay, H2OMeshDisplay, vertTerrainNormals,vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, staggerRainFall, useSedFlux},//		mesh_river3Boulder : idx : 27
			{},
			{sqSqSub, subEnabled, randomHeight, HEcalc, Raincalc, calcLateralErosion, dataVisualization, terrainMeshDisplay, terrainMeshDisplay, vertTerrainNormals, vertH2ONormals, H2OMeshDisplay, useMidpointMethod, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux, staggerRainFall},//		mesh_fileSmall : idx : 29
			{sqSqSub, subEnabled, randomHeight, HEcalc, Raincalc, calcLateralErosion, dataVisualization, terrainMeshDisplay, terrainMeshDisplay, vertTerrainNormals, vertH2ONormals, H2OMeshDisplay, useMidpointMethod, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux, staggerRainFall},//		mesh_fileLargeFlat : idx : 30
			{sqSqSub, subEnabled, randomHeight, HEcalc, Raincalc, calcLateralErosion, dataVisualization, terrainMeshDisplay, terrainMeshDisplay, vertTerrainNormals, vertH2ONormals, H2OMeshDisplay, useMidpointMethod, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux, staggerRainFall},//		mesh_fileLargetilt : idx : 31
			{sqSqSub, heightMapMade, erosionProc, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, vertTerrainNormals, vertH2ONormals, H2OMeshDisplay, renderGui, useMidpointMethod, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux, staggerRainFall},//		mesh_fileLargeTilt : idx : 32
			{sqSqSub, heightMapMade, erosionProc, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, terrainMeshDisplay, vertTerrainNormals, vertH2ONormals, H2OMeshDisplay, renderGui, useMidpointMethod, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux, staggerRainFall},//		mesh_fileGen4 : idx : 33
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, useMidpointMethod, terrainMeshDisplay, H2OMeshDisplay, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		 mesh_torus1	  : idx : 34
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, useMidpointMethod, terrainMeshDisplay, H2OMeshDisplay, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		 mesh_torus2	  : idx : 35
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, useMidpointMethod, terrainMeshDisplay, H2OMeshDisplay, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		 mesh_torus3	  : idx : 36
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, useMidpointMethod, terrainMeshDisplay, H2OMeshDisplay, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		 mesh_torus4	  : idx : 37
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, useMidpointMethod, terrainMeshDisplay, H2OMeshDisplay, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		 mesh_torus5	  : idx : 38
			{sqSqSub, heightMapMade, erosionProc, wrapAroundMesh, meshIsGenerated, HEcalc, Raincalc, Pipes, calcLateralErosion, dataVisualization, useMidpointMethod, terrainMeshDisplay, H2OMeshDisplay, vertH2ONormals, renderGui, renderDemoGui, debugMode, scaleSedPipes, limitWaterSedCap, ignoreYVelocity, useLowestKGlobally, useSedFlux},//		 mesh_torus6	  : idx : 39
			{},//		
	}));	
	//need to have one per mesh - idxed by mesh ID
	public static final ArrayList<Double[]> initMeshErosionConsts = new ArrayList<Double[]>(Arrays.asList (new Double[][] { 
		{0.035, 0.25, 0.45, 0.05},        //		mesh_ramp : idx : 0
		{0.035, 0.25, 0.45, 0.05},        //		mesh_coneUp : idx : 1
		{0.035, 0.25, 0.45, 0.05},        //		mesh_coneDown : idx : 2
		{0.035, 0.25, 0.45, 0.05},        //		mesh_2coneDown : idx : 3
		{0.035, 0.25, 0.5003, 0.04},      //		mesh_volcano : idx : 4
		{0.035, 0.25, 0.5003, 0.04},      //		mesh_2volcano : idx : 5
		{0.0358, 0.1408, 0.4983, 0.0362}, //		mesh_dam : idx : 6
		{0.0358, 0.1408, 0.369,  0.03},   //		mesh_damWall : idx : 7
		{0.1059, 0.05, 0.4, 0.0352},      //		mesh_riverLedge : idx : 8
		{0.06, 0.1, 0.2467, 0.06},        //		mesh_column : idx : 9
		{0.06, 0.2, 0.743, 0.0674},       //		mesh_tiltColumn : idx : 10
		{0.06, 0.2, 0.743, 0.0674},       //		mesh_tiltShelfColumn : idx : 11
		{0.035, 0.25, 0.25, 0.25},        //		mesh_riverPrimary : idx : 12
		{0.035, 0.25, 0.25, 0.25},        //		mesh_riverStraightPier : idx : 13
		{0.035, 0.25, 0.6058, 0.0545},    //		mesh_riverStraightTributary : idx : 14
		{0.035, 0.25, 0.25, 0.25},        //		mesh_riverStraight2Pier : idx : 15
		{0.035, 0.25, 0.6058, 0.0545},    //		mesh_riverStraight2Tributary : idx : 16
		{0.035, 0.25, 0.6058, 0.0545},    //		mesh_riverStraight2Trib2Pier : idx : 17
		{0.035, 0.25, 0.45, 0.05},        //		mesh_riverColumn : idx : 18
		{0.035, 0.25, 0.45, 0.05},        //		mesh_riverManyColumns : idx : 19
		{0.035, 0.25, 0.55, 0.035},       //		mesh_columnWall : idx : 20
		{0.035, 0.25, 0.55, 0.035},       //		mesh_waterAroundColumnWall : idx : 21
		{0.035, 0.25, 0.55, 0.035},       //		mesh_damBetweenWalls : idx : 22
		{0.035, 0.25, 0.55, 0.038},       //		mesh_damBetweenLargeRiver : idx : 23
		{0.035, 0.25, 0.25, 0.25},        //		mesh_riverFlatTerrain : idx : 24
		{0.035, 0.25, 0.743, 0.0754},     //		mesh_river1Boulder : idx : 25
		{0.035, 0.25, 0.743, 0.0754},     //		mesh_river2Boulder : idx : 26
		{0.035, 0.25, 0.743, 0.0754},     //		mesh_river3Boulder : idx : 27
		{},
		{0.0, 0.0, 0.0, 0.0},		      //	    mesh_fileAutoSubLargeTilt : idx : 40
		{0.035, 0.25, 0.252, 0.06},       //		small flat single point file mesh - not generated : idx : 29
		{0.035, 0.25, 0.252, 0.06},       //		flat larger file mesh not generated : idx : 30
		{0.035, 0.25, 0.252, 0.06},       //		tilted larger file mesh not generated : idx : 31
		{0.035, 0.25, 0.252, 0.06},       //		small flat mesh generated : idx : 32
		{0.035, 0.25, 0.252, 0.06},       //		large tilted mesh generated : idx : 33
		{0.035, 0.25, 0.252, 0.06},       //		torus1 : idx : 34
		{0.035, 0.25, 0.252, 0.06},       //		torus2 : idx : 35
		{0.035, 0.25, 0.252, 0.06},       //		torus3 : idx : 36
		{0.035, 0.25, 0.252, 0.06},       //		torus4 : idx : 37
		{0.035, 0.25, 0.252, 0.06},       //		torus5 : idx : 38
		{0.035, 0.25, 0.252, 0.06},	      //		torus6 : idx : 39
		{0.0, 0.0, 0.0, 0.0}		      //	    ....
						
	}));
	
	public static final ArrayList<Double[]> initMeshSimulationConsts = new ArrayList<Double[]>(Arrays.asList (new Double[][] { 
			{0.1, 1.0, 1.0, 20.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 1.0, 1.0, 0.0,.25},//		mesh_ramp : idx : 0
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.128, 0.24, 33.0, 1.0, 0.0,.25},//		mesh_coneUp : idx : 1
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.128, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_coneDown : idx : 2
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.128, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_2coneDown : idx : 3
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.02, 0.24, 1.0, 1.0, 0.0,.25},//		mesh_volcano : idx : 4
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.02, 0.24, 1.0, 1.0, 0.0,.25},//		mesh_2volcano : idx : 5
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_dam : idx : 6
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_damWall : idx : 7
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_riverLedge : idx : 8
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_column : idx : 9
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.034, 0.24, 1.0, 1.0, 0.0,.25},//		mesh_tiltColumn : idx : 10
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.034, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_tiltShelfColumn : idx : 11
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_riverPrimary : idx : 12
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_riverStraightPier : idx : 13
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_riverStraightTributary : idx : 14
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_riverStraight2Pier : idx : 15
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_riverStraight2Tributary : idx : 16
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_riverStraight2Trib2Pier : idx : 17
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_riverColumn : idx : 18
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_riverManyColumns : idx : 19
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_columnWall : idx : 20
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_waterAroundColumnWall : idx : 21
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_damBetweenWalls : idx : 22
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_damBetweenLargeRiver : idx : 23
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 0.0, 1.0, 0.0,.25},//		mesh_riverFlatTerrain : idx : 24
			{0.1, 1.0, 1.0, 30.0, 200.0, 0.333333, 1.0, 4.0, 10.0, 0.25, 0.24, 1.0, 1.0, 0.0,.25},//		mesh_river1Boulder : idx : 25
			{0.1, 1.0, 1.0, 30.0, 80.0,  0.333333, 1.0, 4.0, 10.0, 0.03, 0.24, 100.0, 1.0, 0.0,.25},//		mesh_river2Boulder : idx : 26
			{0.1, 1.0, 1.0, 30.0, 4.0,   0.333333, 1.0, 4.0, 10.0, 0.03, 0.24, 100.0, 1.0, 0.0,.25},//		mesh_river3Boulder : idx : 27
			{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0},//		unused : idx : 28
			{0.1, 1.0, 1.0, 20.0, 80.0, 0.333333, 1.0, 4.0, 10.0, 0.03, 0.24, 100.0, 1.0, 0.0,.25},//		small flat single point file mesh - not generated : idx : 29
			{0.1, 1.0, 1.0, 20.0, 80.0, 0.333333, 1.0, 4.0, 10.0, 0.03, 0.24, 100.0, 1.0, 0.0,.25},//		flat larger file mesh not generated : idx : 30
			{0.1, 1.0, 1.0, 20.0, 80.0, 0.333333, 1.0, 4.0, 10.0, 0.03, 0.24, 100.0, 1.0, 0.0,.25},//		tilted larger file mesh not generated : idx : 31
			{0.1, 1.0, 1.0, 20.0, 80.0, 0.333333, 1.0, 4.0, 10.0, 0.03, 0.24, 100.0, 1.0, 0.0,.4},//		small flat mesh generated : idx : 32
			{0.1, 1.0, 1.0, 20.0, 80.0, 0.333333, 1.0, 4.0, 10.0, 0.03, 0.24, 100.0, 1.0, 0.0,.4},//		large tilted mesh generated : idx : 33
			{0.1, 1.0, 1.0, 20.0, 80.0, 0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 1.0, 1.0, 0.0,.25},//		torus1 : idx : 34 
			{0.1, 1.0, 1.0, 20.0, 80.0, 0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 1.0, 1.0, 0.0,.25},//		torus2 : idx : 35 
			{0.1, 1.0, 1.0, 20.0, 80.0, 0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 1.0, 1.0, 0.0,.25},//		torus3 : idx : 36 
			{0.1, 1.0, 1.0, 20.0, 80.0, 0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 1.0, 1.0, 0.0,.25},//		torus4 : idx : 37 
			{0.1, 1.0, 1.0, 20.0, 80.0, 0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 1.0, 1.0, 0.0,.25},//		torus5 : idx : 38 
			{0.1, 1.0, 1.0, 20.0, 80.0, 0.333333, 1.0, 4.0, 10.0, 0.0010, 0.24, 1.0, 1.0, 0.0,.25},//		torus6 : idx : 39 
			{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0},//		unused : idx : 40
			}));
	
	//mesh constant names as strings - for building ara of init bool/var vals
	public static final String[] meshConstNames = {
		"mesh_ramp",     //0;
		"mesh_coneUp",     //1;
		"mesh_coneDown",     //2;
		"mesh_2coneDown",     //3;
		"mesh_volcano",     //4;
		"mesh_2volcano",     //5;
		"mesh_dam",     //6;
		"mesh_damWall",     //7;
		"mesh_riverLedge",     //8;
		"mesh_column",     //9;
		"mesh_tiltColumn",     //10;
		"mesh_tiltShelfColumn",     //11;
		"mesh_riverPrimary",     //12;				
		"mesh_riverStraightPier",     //13;
		"mesh_riverStraightTributary",     //14;
		"mesh_riverStraight2Pier",     //15;
		"mesh_riverStraight2Tributary",     //16;
		"mesh_riverStraight2Trib2Pier",     //17;	//6
		"mesh_riverColumn",     //18;				//7
		"mesh_riverManyColumns",     //19;	
		"mesh_columnWall",     //20;
		"mesh_waterAroundColumnWall",     //21;
		"mesh_damBetweenWalls",     //22;
		"mesh_damBetweenLargeRiver",     //23;		//12
		"mesh_riverFlatTerrain",     //24;				
		"mesh_river1Boulder",     //25;
		"mesh_river2Boulder",     //26;
		"mesh_river3Boulder",     //27;
		"mesh_riverGen4",     //28;		
		"mesh_fileSmall",     //29;		
		"mesh_fileLargeFlat",     //30;		
		"mesh_fileLargeTilt",     //31;		
		"mesh_fileGen4",     //32;		
		"mesh_fileAutoSubLargeTilt",     //33;
		"mesh_torus1",
		"mesh_torus2",
		"mesh_torus3",
		"mesh_torus4",
		"mesh_torus5",
		"mesh_torus6"
	};
	
	/*
	 * 		playlist variables to automate playback of meshes for demo
	 */
	
	//playlist idx's
	public static final int plAllMeshes = 0;		//all meshes except manually subdivided ones
	public static final int plGenMesh1 = 1;
	public static final int plGenMesh2 = 2;
	public static final int plGenMesh3 = 3;
	public static final int plRiver1 = 4;
	public static final int plRiver2 = 5;
	public static final int plBoulder1 = 6;
	public static final int plBoulder2 = 7;
	
	//lists to be used for playing automated erosion demos
	public static final int[][] demoPlaylists = {
		{	mesh_ramp,	mesh_coneUp, mesh_coneDown, mesh_2coneDown, mesh_volcano,	mesh_2volcano,	mesh_dam,	mesh_damWall, mesh_riverLedge,	mesh_column, mesh_tiltColumn, mesh_tiltShelfColumn,
			mesh_riverPrimary,mesh_riverStraightPier,	mesh_riverStraightTributary,mesh_riverStraight2Pier,mesh_riverStraight2Tributary,mesh_riverStraight2Trib2Pier,mesh_riverColumn,	mesh_riverManyColumns,
			mesh_columnWall,mesh_waterAroundColumnWall,	mesh_damBetweenWalls,mesh_damBetweenLargeRiver,	mesh_riverFlatTerrain,	mesh_river1Boulder,	mesh_river2Boulder,	mesh_river3Boulder, mesh_fileAutoSubSmall, mesh_fileAutoSubLargeTilt,},			//plAllMeshes
		
	};
	
	//each mesh should be allowed to run for this many cycles before cycling on to the next mesh
	public static final int[][] demoPlaylistsSimCycles = {
		{ 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 
			3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 
			3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 
			3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 
			3000, 3000,3000, 3000, 3000, 3000, 3000, 3000, 3000, 
			3000, 3000, 3000},		
	};
	
	
	//names of flags to be ignored from prepop array above - these are debugging flags, or else flags related to gui functionality, or flags that are related the prepop array itself
	//we don't want preppop array to modify these when meshes are loaded
	public static final HashSet<Integer> ignoreFlagNames = new HashSet<Integer> (Arrays.asList(new Integer[]{
			simulate,	
			useStoredErosionMeshVals,
			mseHotspotMenusActive,		
			useStamSolver,				//	= 43;
			addVelStamSolver, 			//	= 44;	
			shiftKeyPressed,			//	= 46;
			demoDevMode,
			savePic, 					//	= 57;
			debugModeCnsl, 				//	= 58;
			debugOutputFileOpen, 		//	= 59;
			dispCutAwayX, 				//	= 60;
			dispCutAwayZ, 				//	= 61;
			dispNon1KVals, 				//	= 62;
			dispSedTransLeftoverVals,	//	= 63;
			debugSubdivision,			//	= 64;	
			dispOriginalMesh,			//	= 68;
			dispAdjNodes,				//	= 69;
			dispWrapToNodes,			//	= 70;
			dispPipeLengths,			//	= 71;
			dispFluxVals,			 	//	= 72;
			dispHeightDiffs,			//	= 73;
			batchMode,					//	= 82;	
			sailBoat,					//	= 83;
			showWrapNodes,				//	= 84;
			dispOldMeshVals				//	= 85;			
	}));
	//boolean flag names as strings
	public static final String[] flagNamesVals = {	
		"sqSqSub",					//	= 0;
		"loopSub", 					//	= 1;
		"catClkSub", 				//	= 2;
		"subEnabled", 				//	= 3;
		"multByNormal", 			//	= 4;	
		"heightProc", 				//	= 5;
		"randomHeight", 			//	= 6;       
		"heightMapMade", 			//	= 7;
		"erosionProc", 				//	= 8;
		"wrapAroundMesh", 			//	= 9;
		"lakeSourceWrapMesh",		//	= 10;
		"meshIsGenerated", 			//	= 11;
		"simulate",					//	= 12;
		"TWcalc", 					//	= 13;
		"HEcalc", 					//	= 14;
		"Raincalc",					//	= 15;
		"Pipes", 					//	= 16;
		"calcLateralErosion", 		//	= 17;
		"modSoilSoftness", 			//	= 18;
		"dataVisualization", 		//	= 19;	
		"terrainMeshDisplay", 		//	= 20;
		"strokeDisplayTerrain", 	//	= 21;
		"showTerrainNormals", 		//	= 22;
		"vertTerrainNormals", 		//	= 23;  
		"H2OMeshDisplay", 			//	= 24;
		"showH2OVelocity", 			//	= 25;
		"strokeDisplayH2O", 		//	= 26;
		"showH2ONormals", 			//	= 27;	
		"vertH2ONormals", 			//	= 28;		
		"showBoundaryNodes", 		//	= 29;
		"dispSedSrcVecs", 			//	= 30;
		"sedMeshDisplay", 			//	= 31;
		"strokeDisplaySED", 		//	= 32;
		"showSEDNormals", 			//	= 33;
		"vertSEDNormals", 			//	= 34;
		"sedCapMeshDisplay", 		//	= 35;
		"strokeDisplaySedCap", 		//	= 36;
		"showSedCapNormals", 		//	= 37;
		"vertSedCapNormals", 		//	= 38;  
		"sedConcMeshDisplay", 		//	= 39;
		"strokeDisplaySedConc", 	//	= 40;
		"showSedConcNormals", 		//	= 41;
		"vertSedConcNormals", 		//	= 42;  
		"useStamSolver",			//	= 43;
		"addVelStamSolver", 		//	= 44;	
		"renderGui", 				//	= 45;    
		"shiftKeyPressed",			//	= 46;
		"guiMouseOverEnabled",		//	= 47;
		"guiDispButtonMenu",		//	= 48;
		"guiDispBoolMenu",			//	= 49;
		"guiDispBottomMenu",		//	= 50;
		"guiDispTopDataVals",		//	= 51;
		"guiDispConsole",			//	= 52;
		"renderDemoGui",			//	= 53;
		"guiDispDemoMode",			//	= 54;
		"demoDevMode",				//	= 55;
		"debugMode", 				//	= 56;
		"savePic", 					//	= 57;
		"debugModeCnsl", 			//	= 58;
		"debugOutputFileOpen", 		//	= 59;
		"dispCutAwayX", 			//	= 60;
		"dispCutAwayZ", 			//	= 61;
		"dispNon1KVals", 			//	= 62;
		"dispSedTransLeftoverVals",	//	= 63;
		"debugSubdivision",			//	= 64;
		"scaleSedPipes",			//	= 65;
		"limitWaterSedCap",			//	= 66;
		"ignoreYVelocity",			//	= 67;
		"dispOriginalMesh",			//	= 68;
		"dispAdjNodes",				//	= 69;
		"dispWrapToNodes",			//	= 70;
		"dispPipeLengths",			//	= 71;
		"dispFluxVals",			 	//	= 72;
		"dispHeightDiffs",			//	= 73;
		"useLowestKGlobally",		//	= 74;	
		"subdivRiverMesh",			//	= 75;	
		"rainOnTerrain1Cyc",		//	= 76;
		"useSedFlux",				//	= 77;
		"useSedConc",				//	= 78;	
		"pullSedFromDryNodes",		//	= 79;	
		"erodeDryNodes",			//	= 80;
		"advectErosionDep",			//	= 81;		
		"batchMode",				//	= 82;	
		"sailBoat",					//	= 83;
		"showWrapNodes",			//	= 84;
		"dispOldMeshVals",			//	= 85;
		"autoSubdivide",			//  = 86
		"staggerRainFall",			//  = 87
		"mseHotspotMenusActive",	//	= 88;
		"useStoredErosionMeshVals"  //= 89;
		};			
	
	/*
	 * TODO : map holding mappings from mesh idx to structure of mesh info - NOTE:entries can be changed (map var cannot be reassigned but individual entries can be over-written)
	 */
	public static final HashMap<Integer, myMeshDescriber> meshIDInfo;
	static{
		meshIDInfo = new HashMap<Integer, myMeshDescriber>();
		//meshIDInfo.put
	};

	
/////replace all below when meshIDInfo map is done
	
// 	//type of mesh based on predfined ids	
	public static final HashMap<Integer, Integer> meshType;
	static{
		meshType = new HashMap<Integer, Integer>();	
		meshType.put(mesh_riverPrimary 		      , riverMesh);
		meshType.put(mesh_riverStraightPier       , riverMesh);
		meshType.put(mesh_riverStraightTributary  , riverMesh);
		meshType.put(mesh_riverStraight2Pier      , riverMesh);
		meshType.put(mesh_riverStraight2Tributary , riverMesh);
		meshType.put(mesh_riverStraight2Trib2Pier , riverMesh);
		meshType.put(mesh_dam                     , genMesh);
		meshType.put(mesh_damWall                 , genMesh);
		meshType.put(mesh_riverLedge              , genMesh);
		meshType.put(mesh_column                  , genMesh);
		meshType.put(mesh_tiltColumn              , genMesh);
		meshType.put(mesh_tiltShelfColumn         , genMesh);
		meshType.put(mesh_riverFlatTerrain	      , riverMesh);
		meshType.put(mesh_river1Boulder           , riverMesh);
		meshType.put(mesh_river2Boulder           , riverMesh);
		meshType.put(mesh_river3Boulder           , riverMesh);
		meshType.put(mesh_riverGen4				  , riverMesh);
		meshType.put(mesh_ramp                    , genMesh);
		meshType.put(mesh_coneUp                  , genMesh);
		meshType.put(mesh_coneDown                , genMesh);
		meshType.put(mesh_2coneDown               , genMesh);
		meshType.put(mesh_volcano                 , genMesh);
		meshType.put(mesh_2volcano                , genMesh);
		meshType.put(mesh_riverColumn		      , riverMesh);
		meshType.put(mesh_riverManyColumns 	      , riverMesh);
		meshType.put(mesh_columnWall              , riverMesh);
		meshType.put(mesh_waterAroundColumnWall   , riverMesh);
		meshType.put(mesh_damBetweenWalls         , riverMesh);
		meshType.put(mesh_damBetweenLargeRiver    , riverMesh);
		meshType.put(mesh_fileSmall 			  , fileMesh);
		meshType.put(mesh_fileLargeFlat 		  , fileMesh);
		meshType.put(mesh_fileLargeTilt 		  , fileMesh);
		meshType.put(mesh_fileAutoSubSmall 		  , fileMesh);
		meshType.put(mesh_fileAutoSubLargeTilt    , fileMesh);
		meshType.put(mesh_torus1                  , genMesh);
		meshType.put(mesh_torus2                  , genMesh);
		meshType.put(mesh_torus3                  , genMesh);
		meshType.put(mesh_torus4                  , genMesh);
		meshType.put(mesh_torus5                  , genMesh);
		meshType.put(mesh_torus6                  , genMesh);
	};                                            
	
//	//whether or not a generated river mesh wraps around where -every- quantity is copied (as if adjacent) in x direction
	public static final HashMap<Integer, Boolean> meshWrapX;
	static{
		meshWrapX = new HashMap<Integer, Boolean>();	
		meshWrapX.put(mesh_riverPrimary 		      ,true); 
		meshWrapX.put(mesh_riverStraightPier       	  ,true); 
		meshWrapX.put(mesh_riverStraightTributary  	  ,true); 
		meshWrapX.put(mesh_riverStraight2Pier      	  ,true); 
		meshWrapX.put(mesh_riverStraight2Tributary 	  ,true); 
		meshWrapX.put(mesh_riverStraight2Trib2Pier 	  ,true); 
		meshWrapX.put(mesh_dam                     	  ,false); 
		meshWrapX.put(mesh_damWall                 	  ,false); 
		meshWrapX.put(mesh_riverLedge              	  ,false); 
		meshWrapX.put(mesh_column                  	  ,false); 
		meshWrapX.put(mesh_tiltColumn              	  ,false); 
		meshWrapX.put(mesh_tiltShelfColumn         	  ,false); 
		meshWrapX.put(mesh_riverFlatTerrain	    	  ,true); 
		meshWrapX.put(mesh_river1Boulder           	  ,true); 
		meshWrapX.put(mesh_river2Boulder           	  ,true); 
		meshWrapX.put(mesh_river3Boulder           	  ,true); 
		meshWrapX.put(mesh_riverGen4				  ,true); 
		meshWrapX.put(mesh_ramp                    	  ,false); 
		meshWrapX.put(mesh_coneUp                  	  ,false); 
		meshWrapX.put(mesh_coneDown                	  ,false); 
		meshWrapX.put(mesh_2coneDown               	  ,false); 
		meshWrapX.put(mesh_volcano                 	  ,false); 
		meshWrapX.put(mesh_2volcano                	  ,false); 
		meshWrapX.put(mesh_riverColumn		          ,false); 
		meshWrapX.put(mesh_riverManyColumns 	      ,false); 
		meshWrapX.put(mesh_columnWall              	  ,false); 
		meshWrapX.put(mesh_waterAroundColumnWall   	  ,false); 
		meshWrapX.put(mesh_damBetweenWalls         	  ,false); 
		meshWrapX.put(mesh_damBetweenLargeRiver    	  ,false); 
		meshWrapX.put(mesh_fileSmall 				  ,false); 
		meshWrapX.put(mesh_fileLargeFlat 			  ,false); 
		meshWrapX.put(mesh_fileLargeTilt 			  ,false); 
		meshWrapX.put(mesh_fileAutoSubSmall 		  ,false); 
		meshWrapX.put(mesh_fileAutoSubLargeTilt    	  ,false); 
		meshWrapX.put(mesh_torus1                     ,false); 
		meshWrapX.put(mesh_torus2                     ,false); 
		meshWrapX.put(mesh_torus3                     ,false); 
		meshWrapX.put(mesh_torus4                     ,false); 
		meshWrapX.put(mesh_torus5                     ,false); 
		meshWrapX.put(mesh_torus6                     ,false); 	
	};
	
//	//whether or not a generated river mesh wraps around where -every- quantity is copied (as if adjacent) in z direction
	public static final HashMap<Integer, Boolean> meshWrapZ;
	static{
		meshWrapZ = new HashMap<Integer, Boolean>();	
		meshWrapZ.put(mesh_riverPrimary 		      ,false); 
		meshWrapZ.put(mesh_riverStraightPier       	  ,false); 
		meshWrapZ.put(mesh_riverStraightTributary  	  ,false); 
		meshWrapZ.put(mesh_riverStraight2Pier      	  ,false); 
		meshWrapZ.put(mesh_riverStraight2Tributary 	  ,false); 
		meshWrapZ.put(mesh_riverStraight2Trib2Pier 	  ,false); 
		meshWrapZ.put(mesh_dam                     	  ,false); 
		meshWrapZ.put(mesh_damWall                 	  ,false); 
		meshWrapZ.put(mesh_riverLedge              	  ,false); 
		meshWrapZ.put(mesh_column                  	  ,false); 
		meshWrapZ.put(mesh_tiltColumn              	  ,false); 
		meshWrapZ.put(mesh_tiltShelfColumn         	  ,false); 
		meshWrapZ.put(mesh_riverFlatTerrain	    	  ,false); 
		meshWrapZ.put(mesh_river1Boulder           	  ,false); 
		meshWrapZ.put(mesh_river2Boulder           	  ,false); 
		meshWrapZ.put(mesh_river3Boulder           	  ,false); 
		meshWrapZ.put(mesh_riverGen4				  ,false); 
		meshWrapZ.put(mesh_ramp                    	  ,false); 
		meshWrapZ.put(mesh_coneUp                  	  ,false); 
		meshWrapZ.put(mesh_coneDown                	  ,false); 
		meshWrapZ.put(mesh_2coneDown               	  ,false); 
		meshWrapZ.put(mesh_volcano                 	  ,false); 
		meshWrapZ.put(mesh_2volcano                	  ,false); 
		meshWrapZ.put(mesh_riverColumn		          ,false); 
		meshWrapZ.put(mesh_riverManyColumns 	      ,false); 
		meshWrapZ.put(mesh_columnWall              	  ,false); 
		meshWrapZ.put(mesh_waterAroundColumnWall   	  ,false); 
		meshWrapZ.put(mesh_damBetweenWalls         	  ,false); 
		meshWrapZ.put(mesh_damBetweenLargeRiver    	  ,false); 
		meshWrapZ.put(mesh_fileSmall 				  ,false); 
		meshWrapZ.put(mesh_fileLargeFlat 			  ,false); 
		meshWrapZ.put(mesh_fileLargeTilt 			  ,false); 
		meshWrapZ.put(mesh_fileAutoSubSmall 		  ,false); 
		meshWrapZ.put(mesh_fileAutoSubLargeTilt    	  ,false); 
		meshWrapZ.put(mesh_torus1                     ,false); 
		meshWrapZ.put(mesh_torus2                     ,false); 
		meshWrapZ.put(mesh_torus3                     ,false); 
		meshWrapZ.put(mesh_torus4                     ,false); 
		meshWrapZ.put(mesh_torus5                     ,false); 
		meshWrapZ.put(mesh_torus6                     ,false); 
	};	
//	//whether or not a mesh is solid (ie uses normal for "down"
	public static final HashMap<Integer, Boolean> meshIsSolid;
	static{
		meshIsSolid = new HashMap<Integer, Boolean>();	
		meshIsSolid.put(mesh_riverPrimary 		      		,false); 
		meshIsSolid.put(mesh_riverStraightPier       	    ,false); 
		meshIsSolid.put(mesh_riverStraightTributary  	    ,false); 
		meshIsSolid.put(mesh_riverStraight2Pier      	    ,false); 
		meshIsSolid.put(mesh_riverStraight2Tributary 	    ,false); 
		meshIsSolid.put(mesh_riverStraight2Trib2Pier 	    ,false); 
		meshIsSolid.put(mesh_dam                     	    ,false); 
		meshIsSolid.put(mesh_damWall                 	    ,false); 
		meshIsSolid.put(mesh_riverLedge              	    ,false); 
		meshIsSolid.put(mesh_column                  	    ,false); 
		meshIsSolid.put(mesh_tiltColumn              	    ,false); 
		meshIsSolid.put(mesh_tiltShelfColumn         	    ,false); 
		meshIsSolid.put(mesh_riverFlatTerrain	    	    ,false); 
		meshIsSolid.put(mesh_river1Boulder           	    ,false); 
		meshIsSolid.put(mesh_river2Boulder           	    ,false); 
		meshIsSolid.put(mesh_river3Boulder           	    ,false); 
		meshIsSolid.put(mesh_riverGen4				  		,false); 
		meshIsSolid.put(mesh_ramp                    	    ,false); 
		meshIsSolid.put(mesh_coneUp                  	    ,false); 
		meshIsSolid.put(mesh_coneDown                	    ,false); 
		meshIsSolid.put(mesh_2coneDown               	    ,false); 
		meshIsSolid.put(mesh_volcano                 	    ,false); 
		meshIsSolid.put(mesh_2volcano                	    ,false); 
		meshIsSolid.put(mesh_riverColumn		            ,false); 
		meshIsSolid.put(mesh_riverManyColumns 	            ,false); 
		meshIsSolid.put(mesh_columnWall              	    ,false); 
		meshIsSolid.put(mesh_waterAroundColumnWall   	    ,false); 
		meshIsSolid.put(mesh_damBetweenWalls         	    ,false); 
		meshIsSolid.put(mesh_damBetweenLargeRiver    	    ,false); 
		meshIsSolid.put(mesh_fileSmall 				        ,false); 
		meshIsSolid.put(mesh_fileLargeFlat 			        ,false); 
		meshIsSolid.put(mesh_fileLargeTilt 			        ,false); 
		meshIsSolid.put(mesh_fileAutoSubSmall 		        ,false); 
		meshIsSolid.put(mesh_fileAutoSubLargeTilt    	    ,false); 
		meshIsSolid.put(mesh_torus1                         ,true); 
		meshIsSolid.put(mesh_torus2                         ,true); 
		meshIsSolid.put(mesh_torus3                         ,true); 
		meshIsSolid.put(mesh_torus4                         ,true); 
		meshIsSolid.put(mesh_torus5                         ,true); 
		meshIsSolid.put(mesh_torus6                         ,true); 
	};		

//	//file name of mesh, if exists
	public static final HashMap<Integer, String> meshFileName;
	static{
		meshFileName = new HashMap<Integer, String>();	
		meshFileName.put(mesh_riverPrimary 		      		,"");
		meshFileName.put(mesh_riverStraightPier       	    ,"");
		meshFileName.put(mesh_riverStraightTributary  	    ,"");
		meshFileName.put(mesh_riverStraight2Pier      	    ,"");
		meshFileName.put(mesh_riverStraight2Tributary 	    ,"");
		meshFileName.put(mesh_riverStraight2Trib2Pier 	    ,"");
		meshFileName.put(mesh_dam                     	    ,"");
		meshFileName.put(mesh_damWall                 	    ,"");
		meshFileName.put(mesh_riverLedge              	    ,"");
		meshFileName.put(mesh_column                  	    ,"");
		meshFileName.put(mesh_tiltColumn              	    ,"");
		meshFileName.put(mesh_tiltShelfColumn         	    ,"");
		meshFileName.put(mesh_riverFlatTerrain	    	    ,"");
		meshFileName.put(mesh_river1Boulder           	    ,"");
		meshFileName.put(mesh_river2Boulder           	    ,"");
		meshFileName.put(mesh_river3Boulder           	    ,"");
		meshFileName.put(mesh_riverGen4				  		,"");
		meshFileName.put(mesh_ramp                    	    ,"");
		meshFileName.put(mesh_coneUp                  	    ,"");
		meshFileName.put(mesh_coneDown                	    ,"");
		meshFileName.put(mesh_2coneDown               	    ,"");
		meshFileName.put(mesh_volcano                 	    ,"");
		meshFileName.put(mesh_2volcano                	    ,"");
		meshFileName.put(mesh_riverColumn		            ,"");
		meshFileName.put(mesh_riverManyColumns 	            ,"");
		meshFileName.put(mesh_columnWall              	    ,"");
		meshFileName.put(mesh_waterAroundColumnWall   	    ,"");
		meshFileName.put(mesh_damBetweenWalls         	    ,"");
		meshFileName.put(mesh_damBetweenLargeRiver    	    ,"");
		meshFileName.put(mesh_fileSmall 				    ,"plane.ply");
		meshFileName.put(mesh_fileLargeFlat 			    ,"plane2.ply");
		meshFileName.put(mesh_fileLargeTilt 			    ,"plane2Tilt.ply");
		meshFileName.put(mesh_fileAutoSubSmall 		        ,"plane.ply");
		meshFileName.put(mesh_fileAutoSubLargeTilt    	    ,"plane2Tilt.ply");
		meshFileName.put(mesh_torus1                        ,"");
		meshFileName.put(mesh_torus2                        ,"");
		meshFileName.put(mesh_torus3                        ,"");
		meshFileName.put(mesh_torus4                        ,"");
		meshFileName.put(mesh_torus5                        ,"");
		meshFileName.put(mesh_torus6                        ,"");
	};			
	
//	//display name of mesh, if exists
	public static final HashMap<Integer, String> meshDispName;
	static{
		meshDispName = new HashMap<Integer, String>();	
		meshDispName.put(mesh_riverPrimary 		      		,"Dual Ramp");                                  
		meshDispName.put(mesh_riverStraightPier       	    ,"Cone facing up");                             
		meshDispName.put(mesh_riverStraightTributary  	    ,"Cone facing down");                           
		meshDispName.put(mesh_riverStraight2Pier      	    ,"Pair of Cones facing down");                  
		meshDispName.put(mesh_riverStraight2Tributary 	    ,"Volcano");                                    
		meshDispName.put(mesh_riverStraight2Trib2Pier 	    ,"Dual peak Volcano");                          
		meshDispName.put(mesh_dam                     	    ,"Dam Break");                                  
		meshDispName.put(mesh_damWall                 	    ,"Dam Break With Wall");                        
		meshDispName.put(mesh_riverLedge              	    ,"Dam Break With Riverbank");                   
		meshDispName.put(mesh_column                  	    ,"Water Column");                               
		meshDispName.put(mesh_tiltColumn              	    ,"Tilted Water Column");                        
		meshDispName.put(mesh_tiltShelfColumn         	    ,"Tilted Water Column w/shelf");                
		meshDispName.put(mesh_riverFlatTerrain	    	    ,"Winding River");                              
		meshDispName.put(mesh_river1Boulder           	    ,"River w Pier");                               
		meshDispName.put(mesh_river2Boulder           	    ,"River w Tributary");                          
		meshDispName.put(mesh_river3Boulder           	    ,"River w 2 Piers");                            
		meshDispName.put(mesh_riverGen4				  		,"River w 2 Tributaries");                      
		meshDispName.put(mesh_ramp                    	    ,"River w 2 Piers and 2 Tribs");                
		meshDispName.put(mesh_coneUp                  	    ,"Wave Crash Into Terrain Column");             
		meshDispName.put(mesh_coneDown                	    ,"Wave Crash Into Multiple Terrain Columns");   
		meshDispName.put(mesh_2coneDown               	    ,"Water Column Inside Ring Wall");              
		meshDispName.put(mesh_volcano                 	    ,"Wave Crash Around Circle Wall");              
		meshDispName.put(mesh_2volcano                	    ,"Water wall between River Banks");             
		meshDispName.put(mesh_riverColumn		            ,"Dual Crashing River");                        
		meshDispName.put(mesh_riverManyColumns 	            ,"Flat Terrain Winding River");                 
		meshDispName.put(mesh_columnWall              	    ,"Valley with 1 boulder");                      
		meshDispName.put(mesh_waterAroundColumnWall   	    ,"Valley with 2 boulders");                     
		meshDispName.put(mesh_damBetweenWalls         	    ,"Valley with 3 boulders");                     
		meshDispName.put(mesh_damBetweenLargeRiver    	    ,"ID - mesh_riverGen4");                        
		meshDispName.put(mesh_fileSmall 				    ,"plane_ply - 4-poly simple peak");             
		meshDispName.put(mesh_fileLargeFlat 			    ,"plane2_ply - 36-poly perpendicular peak");    
		meshDispName.put(mesh_fileLargeTilt 			    ,"plane2Tilt_ply - 36-poly tilted peak");       
		meshDispName.put(mesh_fileAutoSubSmall 		        ,"AUTO plane_ply - 4-poly simple peak");        
		meshDispName.put(mesh_fileAutoSubLargeTilt    	    ,"AUTO plane2Tilt_ply - 36-poly tilted peak");  
		meshDispName.put(mesh_torus1                        ,"1 Torus enclosed surface");                   
		meshDispName.put(mesh_torus2                        ,"2 Torus enclosed surface");                   
		meshDispName.put(mesh_torus3                        ,"3 Torus enclosed surface");                   
		meshDispName.put(mesh_torus4                        ,"4 Torus enclosed surface");                   
		meshDispName.put(mesh_torus5                        ,"5 Torus enclosed surface");                   
		meshDispName.put(mesh_torus6                        ,"6 Torus enclosed surface");                   
	};				

	
	
//	//number of autosubdivisions for mesh, if exists
	public static final HashMap<Integer, Integer> autoSubCnt;
	static{
		autoSubCnt = new HashMap<Integer, Integer>();
		autoSubCnt.put(mesh_fileAutoSubSmall, 6);
		autoSubCnt.put(mesh_fileAutoSubLargeTilt, 5);
	}
//	//file name of mesh, if exists
	public static final HashMap<Integer, HashMap<String, Integer>> torusValues;
	static{
		torusValues = new HashMap<Integer, HashMap<String, Integer>>();	
		HashMap<String,Integer> tmpTorusMap;{
			tmpTorusMap = new HashMap<String,Integer>();
			tmpTorusMap.put("slices", 96);
			tmpTorusMap.put("facets", 48);
			tmpTorusMap.put("radius1", 5);
			tmpTorusMap.put("radius2", 3);
			tmpTorusMap.put("knotRad", 7);			
		}
		torusValues.put(mesh_torus1 , tmpTorusMap);
		{
			tmpTorusMap = new HashMap<String,Integer>();
			tmpTorusMap.put("slices", 96);
			tmpTorusMap.put("facets", 48);
			tmpTorusMap.put("radius1", 5);
			tmpTorusMap.put("radius2", 3);
			tmpTorusMap.put("knotRad", 7);			
		}
		torusValues.put(mesh_torus2 , tmpTorusMap);
		{
			tmpTorusMap = new HashMap<String,Integer>();
			tmpTorusMap.put("slices", 96);
			tmpTorusMap.put("facets", 48);
			tmpTorusMap.put("radius1", 5);
			tmpTorusMap.put("radius2", 3);
			tmpTorusMap.put("knotRad", 7);			
		}
		torusValues.put(mesh_torus3 , tmpTorusMap);
		{
			tmpTorusMap = new HashMap<String,Integer>();
			tmpTorusMap.put("slices", 96);
			tmpTorusMap.put("facets", 48);
			tmpTorusMap.put("radius1", 5);
			tmpTorusMap.put("radius2", 3);
			tmpTorusMap.put("knotRad", 7);			
		}
		torusValues.put(mesh_torus4 , tmpTorusMap);
		{
			tmpTorusMap = new HashMap<String,Integer>();
			tmpTorusMap.put("slices", 96);
			tmpTorusMap.put("facets", 48);
			tmpTorusMap.put("radius1", 5);
			tmpTorusMap.put("radius2", 3);
			tmpTorusMap.put("knotRad", 7);			
		}
		torusValues.put(mesh_torus5 , tmpTorusMap);
		{
			tmpTorusMap = new HashMap<String,Integer>();
			tmpTorusMap.put("slices", 96);
			tmpTorusMap.put("facets", 48);
			tmpTorusMap.put("radius1", 5);
			tmpTorusMap.put("radius2", 3);
			tmpTorusMap.put("knotRad", 7);			
		}
		torusValues.put(mesh_torus6 , tmpTorusMap);
		{
			tmpTorusMap = new HashMap<String,Integer>();
			tmpTorusMap.put("slices", 96);
			tmpTorusMap.put("facets", 48);
			tmpTorusMap.put("radius1", 5);
			tmpTorusMap.put("radius2", 3);
			tmpTorusMap.put("knotRad", 7);			
		}
	};			
		
	//names of files that are "solid"
	//public static final ArrayList<String> quadFileSolid = new ArrayList<String>(Arrays.asList (new String[] { "cube.ply", "torusQ.ply"} ));



	
}//myConsts class
